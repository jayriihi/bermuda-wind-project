{% extends "base.html" %}
{% block content %}

<style>
  .header, .legend { color:#1e2b44!important; }
  .header .big { color:#1e2b44!important; }
  .legend span{
    color:#1e2b44!important; border-color:#1e2b44!important; background:rgba(30,43,68,.06);
  }

    /* Dark card around the chart */
    .chart-wrap{
    padding:10px 12px;
    background: var(--panel, #0f2238);            /* << add */
    color: var(--panel-text, #e6eef8);            /* << add (for any text inside) */
    border:1px solid var(--panel-stroke, rgba(255,255,255,.18));
    border-radius:14px;
    box-shadow:0 6px 20px rgba(0,0,0,.25);        /* subtle lift */
    }
    /* Inner ring just a touch lighter */
    .chartBox{
    padding:6px;
    background: rgba(255,255,255,.03);            /* << add for slight contrast */
    border:1px solid var(--panel-stroke, rgba(255,255,255,.14));
    border-radius:12px;
    }
  .chartBox canvas{ border-radius:inherit; }

  @media (max-width:640px){
    .chart-wrap{ padding:8px; border-radius:12px; }
    .chartBox{ padding:4px; border-radius:10px; }
  }

  .chart-wrap.tall{
  padding:16px 16px 14px;            /* bigger outer box */
  margin:0 auto 16px;
  border:1px solid var(--panel-stroke,rgba(255,255,255,.18));
  border-radius:14px;
  background:var(--panel,#0f2238);
  box-shadow:0 10px 28px rgba(0,0,0,.28);
}

.chart-title{
  color:var(--panel-text,#e6eef8);
  text-align:center;
  font-weight:700;
  font-size:clamp(18px,2.3vw,24px);
  margin:2px 0 10px;
}

.chartBox{
  padding:6px;
  border:1px solid rgba(255,255,255,.14);
  border-radius:12px;
  height:72vh;                        /* leaves room for title/footer */
}

.chart-footer{
  color:var(--panel-text,#e6eef8);
  text-align:center;
  font-weight:700;
  font-size:clamp(16px,2vw,20px);
  padding-top:8px;
  margin-top:10px;
}

@media (max-width:640px){
  .chart-wrap.tall{ padding:12px; }
  .chartBox{ height:68vh; }
}

</style>

  <div class="wrap" style="max-width:520px;margin:0 auto;padding:10px 12px">
    <div class="chart-wrap tall">
      <div class="chart-title">3hr wind direction history</div>
  
      <div class="chartBox">
        <canvas id="wd" style="width:100%;height:100%"></canvas>
      </div>
  
      <div class="chart-footer">
        <span id="lbl-current">Current dir —°</span>
      </div>
    </div>
  </div>
  

<!-- Chart.js + date adapter -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

<script>
  // Theme variables
  const css        = getComputedStyle(document.documentElement);
  const AQUA       = (css.getPropertyValue('--aqua')       || '#00e1d1').trim();
  const GRID       = (css.getPropertyValue('--grid')       || 'rgba(255,255,255,.08)').trim();
  const PANEL_TEXT = (css.getPropertyValue('--panel-text') || '#e6eef8').trim();

  // Inputs from Flask
  const labels  = {{ labels   | tojson }};
  const dirs360 = {{ wind_dirs| tojson }};

  function parseWhen(t){
    if (typeof t === 'number') return new Date(t);
    const s = String(t);
    let d = new Date(s); if (!isNaN(d)) return d;
    d = new Date((s.includes('T') ? s : s.replace(' ', 'T')) + (/[Z+\-]/.test(s) ? '' : 'Z'));
    return isNaN(d) ? null : d;
  }

  const pairs = labels.map((t,i)=>({ t:parseWhen(t), d:Number(dirs360[i]) }))
                      .filter(p=>p.t && Number.isFinite(p.d))
                      .sort((a,b)=>a.t-b.t);
  const times = pairs.map(p=>p.t);
  const dirs  = pairs.map(p=>p.d);

  const tms = times.map(t=>t.getTime());
  const yMaxRaw = new Date(Math.max(...tms));
  const QUARTER = 15 * 60 * 1000;
  const yMaxSnap = new Date(Math.ceil(yMaxRaw.getTime()/QUARTER)*QUARTER);
  const yMinSnap = new Date(yMaxSnap.getTime() - 3*60*60*1000);

  // circular mean and deltas (-180..+180)
  const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
  const S = dirs.reduce((a,d)=>a+Math.sin(toRad(d)),0);
  const C = dirs.reduce((a,d)=>a+Math.cos(toRad(d)),0);
  const meanDeg = toDeg(Math.atan2(S,C));
  const delta = d => ((d - meanDeg + 540) % 360) - 180;
  const deltas = dirs.map(delta);

  const nowDeg = dirs.at(-1);
  const mean360 = ((meanDeg % 360) + 360) % 360;
  document.getElementById('lbl-current').textContent = `Current dir ${Math.round(nowDeg)}°`;

  // span for x axis
  const PAD=5, maxAbs = deltas.length ? Math.max(...deltas.map(Math.abs)) : 50;
  const span = Math.max(100, Math.min(360, 2*maxAbs + 2*PAD));
  const xMin = -span/2, xMax = span/2;

  const points = times.map((t,i)=>({ x:deltas[i], y:t }));
  if (yMaxSnap > times.at(-1)) points.push({ x:deltas.at(-1), y:yMaxSnap });

  // mean reference line at x=0
  const refLine = {
    id:'refLine',
    afterDraw(chart){
      const {ctx, chartArea, scales} = chart; if (!chartArea) return;
      const x0 = scales.x.getPixelForValue(0);
      ctx.save();
      ctx.strokeStyle = 'rgba(0,225,209,0.5)';  // aqua-ish
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x0, chartArea.top); ctx.lineTo(x0, chartArea.bottom); ctx.stroke();
      ctx.restore();
    }
  };

  new Chart(document.getElementById('wd'), {
    type:'line',
    data:{ datasets:[{ data:points, tension:.25, spanGaps:true, borderWidth:2, pointRadius:0,
                       borderColor:AQUA, backgroundColor:'rgba(0,225,209,.14)' }] },
    options:{
      maintainAspectRatio:false,
      animation:false,
      normalized:true,
      plugins:{ legend:{ display:false } },
      scales:{
        x:{
          type:'linear',
          title:{ display:true, text:'Δ° from circular mean', color:PANEL_TEXT },
          min:xMin, max:xMax,
          grid:{ color:GRID },
          ticks:{
            color:AQUA,
            callback:(v)=> (Math.abs(+v)<1e-6 ? `avg ${Math.round(mean360)}°` : v)
          }
        },
        y:{
          type:'time',
          reverse:true, bounds:'ticks', min:yMinSnap, max:yMaxSnap, offset:false,
          time:{ unit:'minute', stepSize:5, round:'minute',
                 displayFormats:{minute:'HH:mm'}, tooltipFormat:'HH:mm' },
          grid:{ color:(ctx)=> (+ctx.tick.value % (15*60*1000)===0 ? 'rgba(255,255,255,.16)' : GRID) },
          ticks:{
            color:AQUA, autoSkip:false,
            callback:(v)=>{
              if (+v === +yMaxSnap) return 'now';
              const mins = Math.round((yMaxSnap - v)/60000);
              if (mins % 15 !== 0) return '';
              if (mins % 60 === 0) return `-${mins/60}h`;
              if (mins < 60) return `-${mins}`;
              const h = Math.floor(mins/60), m = mins%60;
              return `-${h}:${String(m).padStart(2,'0')}`;
            },
            afterBuildTicks:()=>{
              const FIVE = 5*60*1000, out=[];
              for (let t=yMaxSnap.getTime(); t>=yMinSnap.getTime(); t-=FIVE) out.push({value:t});
              return out;
            }
          }
        }
      }
    },
    plugins:[refLine]
  });
</script>

{% endblock %}
